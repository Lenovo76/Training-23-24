# Task 6.1

# Measuring Yaw angle (angle with z-axis) using IMU sensor (MPU 6050)

---

## Defining Variables

First , import <wire.h> library for I2C communication then we start by defining variables needed to measure the yaw angle including :

- Angles measured from both accelerometer and gyroscope sensors
- Yaw angle error resulting from noisy environment
- MPU6050 I2C address
- elapsed time for calculating the reading in degrees
- The number of times to calculate Yaw angle error

```jsx
#include <Wire.h>
const int MPU = 0x68; // MPU6050 I2C address
float AccZ;
float GyroZ;
float gyroAngleZ;
float yaw;
float GyroErrorZ;
float elapsedTime, currentTime, previousTime;
int c = 0;
```

## Initializing Communication for both sensors

Talk to accelerometer and gyroscope configuration registers using hexadecimal MPU_address and setting the full scale ranges for both sensors

```jsx
Wire.beginTransmission(MPU);
  Wire.write(0x1C);                  //Talk to the ACCEL_CONFIG register (1C hex)
  Wire.write(0x10);                  //Set the register bits as 00010000 (+/- 8g full scale range)
  Wire.endTransmission(true);
  // Configure Gyro Sensitivity - Full Scale Range (default +/- 250deg/s)
  Wire.beginTransmission(MPU);
  Wire.write(0x1B);                   // Talk to the GYRO_CONFIG register (1B hex)
  Wire.write(0x10);                   // Set the register bits as 00010000 (1000deg/s full scale)
  Wire.endTransmission(true);
  delay(20);
```

## Reading data from sensors

The following code reads the yaw angle from gyroscope and accelerometer registers and divide the reading by LSB sensitivity value determined from datasheet to get the reading in g in gyroscope and in deg/sec in accelerometer

 

```jsx
// === Read acceleromter data === //
  Wire.beginTransmission(MPU);
  Wire.write(0x3F); // Start with register 0x3B (ACCEL_ZOUT_H)
  Wire.endTransmission(false);
  Wire.requestFrom(MPU, 2, true); // Read 2 registers total
  //For a range of +-2g, we need to divide the raw values by 16384 (LSB sensitivity value) to get it in g, according to the datasheet
  AccZ = (Wire.read() << 8 | Wire.read()) / 16384.0; // Z-axis value
  // === Read gyroscope data === //
  previousTime = currentTime;        // Previous time is stored before the actual time read
  currentTime = millis();            // Current time actual time read
  elapsedTime = (currentTime - previousTime) / 1000; // Divide by 1000 to get seconds
  Wire.beginTransmission(MPU);
  Wire.write(0x47); // Start with register 0x47 (GYRO_ZOUT_H)
  Wire.endTransmission(false);
  Wire.requestFrom(MPU, 2, true); // Read 2 registers total
  // For a 250deg/s range we have to divide first the raw value by 131.0 to get it in deg/sec, according to the datasheet
  GyroZ = (Wire.read() << 8 | Wire.read()) / 131.0;
```

## Calculating IMU sensor errors

This function is used to calculate gyro data error. **Note** that we should place the IMU flat in order to get the proper values, so that we then can get the correct values and since Since we calculate yaw angle which cannot be measured by accelerometer so we get the gyro data error only

```jsx
void calculate_IMU_error() {while (c < 200) {
    Wire.beginTransmission(MPU);
    Wire.write(0x47);
    Wire.endTransmission(false);
    Wire.requestFrom(MPU, 2, true);
    GyroZ = Wire.read() << 8 | Wire.read();
    // Sum all readings
    GyroErrorZ = GyroErrorZ + (GyroZ / 131.0);
    c++;
  }
  //Divide the sum by 200 to get the error value
  GyroErrorZ = GyroErrorZ / 200;
  // Print the error value on the Serial Monitor
  Serial.print("GyroErrorZ: ");
  Serial.println(GyroErrorZ);
```

## Getting the Yaw angle from angular velocity and adding the IMU error

Currently the raw values are in degrees per seconds, deg/s, so we need to multiply by seconds (s) to get the angle in degrees . Then, add the gyroscope error measured in the previous part and printing the yaw angle on serial monitor.

```jsx
/ Correct the output with the calculated error values
  GyroZ = GyroZ + 0.79; // GyroErrorZ ~ (-0.8)
  // Currently the raw values are in degrees per seconds, deg/s, so we need to multiply by seconds (s) to get the angle in degrees
  yaw =  yaw + GyroZ * elapsedTime; //----(deg/s * s = deg)----//
  // Print the yaw angle on the serial monitor
  Serial.println(yaw);
```

## If the Sensor is surrounded by a noisy environment, what type of
filter could used and what is the recommended cutoff frequency
depending on the sensor datasheet?

For a noisy environment , the sensor needs a low pass filter (LPF) which allows low-frequency signals to pass through while attenuating high-frequency noise. Regarding the cut off frequency, it is recommended to be in range of 5Hz to 20 Hz since by setting the cutoff frequency of the low-pass filter within the range of 5Hz to 20Hz, it allows attenuation of high-frequency noise components, reducing their impact on the sensor readings. In addition, The MPU6050 has a default internal low-pass filter with a bandwidth of 42Hz. If the cutoff frequency of the external low-pass filter is set too close to or above the sensor's internal bandwidth, it may result in potential aliasing effects and distortions in the output. Therefore, selecting a cutoff frequency below the internal bandwidth ensures that the external filter complements the internal filtering and maintains a smooth frequency response.